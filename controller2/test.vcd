$date
	Sun Dec 23 15:07:25 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1us
$end
$scope module test $end
$var wire 4 ! C_BE [3:0] $end
$var wire 32 " d [31:0] $end
$var wire 1 # trdy $end
$var wire 1 $ req $end
$var wire 1 % irdy $end
$var wire 1 & frame $end
$var wire 1 ' devsel $end
$var reg 4 ( BE [3:0] $end
$var reg 2 ) address [1:0] $end
$var reg 1 * clk $end
$var reg 1 + force_req $end
$var reg 1 , gnt $end
$var reg 1 - rd_wr $end
$scope module device $end
$var wire 32 . AD [31:0] $end
$var wire 4 / BE [3:0] $end
$var wire 4 0 C_BE [3:0] $end
$var wire 1 * clk $end
$var wire 2 1 devaddress [1:0] $end
$var wire 1 + force_req $end
$var wire 1 , gnt $end
$var wire 1 - rd_wr $end
$var wire 1 # trdy $end
$var wire 3 2 state [2:0] $end
$var wire 1 $ req $end
$var wire 1 % irdy $end
$var wire 1 3 fvalid $end
$var wire 1 4 freq_pending $end
$var wire 1 & frame $end
$var wire 1 5 ffinished $end
$var wire 1 6 fend_count $end
$var wire 1 7 fcount $end
$var wire 1 ' devsel $end
$scope module ic $end
$var wire 32 8 AD [31:0] $end
$var wire 4 9 BE [3:0] $end
$var wire 4 : C_BE [3:0] $end
$var wire 1 * clk $end
$var wire 2 ; devaddress [1:0] $end
$var wire 1 + force_req $end
$var wire 32 < mem1 [31:0] $end
$var wire 32 = mem2 [31:0] $end
$var wire 32 > mem3 [31:0] $end
$var wire 32 ? mem4 [31:0] $end
$var wire 1 - rd_wr $end
$var wire 3 @ state [2:0] $end
$var wire 1 $ req $end
$var wire 1 % irdy $end
$var wire 1 3 fvalid $end
$var wire 1 4 freq_pending $end
$var wire 1 & frame $end
$var wire 1 5 ffinished $end
$var wire 1 6 fend_count $end
$var wire 1 7 fcount $end
$var reg 1 A bus_is_mine $end
$var reg 2 B counter [1:0] $end
$var reg 3 C mp [2:0] $end
$upscope $end
$scope module sm $end
$var wire 1 * clk $end
$var wire 1 + force_req $end
$var wire 1 & frame $end
$var wire 1 , gnt $end
$var wire 1 % irdy $end
$var wire 1 $ req $end
$var wire 1 # trdy $end
$var wire 1 ' devsel $end
$var reg 1 7 fcount $end
$var reg 1 6 fend_count $end
$var reg 1 5 ffinished $end
$var reg 1 D fgnt $end
$var reg 1 4 freq_pending $end
$var reg 1 3 fvalid $end
$var reg 3 E next_state [2:0] $end
$var reg 3 F state [2:0] $end
$upscope $end
$scope module tc $end
$var wire 32 G AD [31:0] $end
$var wire 4 H C_BE [3:0] $end
$var wire 1 * clk $end
$var wire 1 3 fvalid $end
$var wire 3 I state [2:0] $end
$var wire 1 # trdy $end
$var wire 1 ' devsel $end
$var reg 32 J add [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx J
bx I
bz H
bx G
bx F
b0 E
xD
bx C
bx B
xA
bx @
bx ?
bx >
bx =
bx <
bx ;
bz :
bx 9
bx 8
x7
x6
x5
x4
x3
bx 2
bx 1
bz 0
bx /
bx .
x-
1,
0+
0*
bx )
bx (
x'
x&
x%
x$
x#
bx "
bz !
$end
#1
1*
#2
z%
z'
z#
bz "
bz .
bz 8
bz G
b0 2
b0 @
b0 F
b0 I
0*
#3
b0 C
1*
#4
1$
z&
0A
17
06
b0 B
0*
b1 )
b1 1
b1 ;
1+
#5
1*
#6
04
b1 B
0*
#7
1*
#8
b10 B
0*
#9
1*
#10
0$
16
07
b11 B
0*
bz )
bz 1
bz ;
0+
#11
1*
#12
b1 E
1D
0*
0,
#13
1*
#14
b10 E
1$
0&
b1 "
b1 .
b1 8
b1 G
1A
14
0D
b1 2
b1 @
b1 F
b1 I
0*
1,
#15
b1 J
1*
#16
0%
0'
bz "
bz .
bz 8
bz G
b11 E
05
04
b10 2
b10 @
b10 F
b10 I
0*
#17
1*
#18
0#
b10101010101010101010101010101010 "
b10101010101010101010101010101010 .
b10101010101010101010101010101010 8
b10101010101010101010101010101010 G
13
b11 2
b11 @
b11 F
b11 I
0*
#19
b10101010101010101010101010101010 <
1*
#20
b1 C
b10 B
0*
#21
b10101010101010101010101010101010 =
1*
#22
b10 C
b101 E
1&
b1 B
0*
#23
b10101010101010101010101010101010 >
1*
#24
1%
1'
1#
z&
bz "
bz .
bz 8
bz G
b0 E
b101 2
b101 @
b101 F
b101 I
b11 C
b0 B
0*
#25
1*
#26
z%
z'
z#
0A
15
b0 2
b0 @
b0 F
b0 I
0*
#27
b0 C
1*
#28
0*
#29
1*
#30
0*
#31
1*
#32
0*
#33
1*
#34
0*
#35
1*
#36
0*
#37
1*
#38
0*
#39
1*
#40
0*
#41
1*
#42
0*
#43
1*
#44
0*
