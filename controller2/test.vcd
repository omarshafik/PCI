$date
	Sun Dec 23 18:17:48 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1us
$end
$scope module test $end
$var wire 32 ! d [31:0] $end
$var wire 1 " trdy $end
$var wire 1 # req $end
$var wire 1 $ irdy $end
$var wire 1 % frame $end
$var wire 1 & devsel $end
$var wire 4 ' C_BE [3:0] $end
$var reg 4 ( BE [3:0] $end
$var reg 2 ) address [1:0] $end
$var reg 1 * clk $end
$var reg 1 + force_req $end
$var reg 1 , gnt $end
$var reg 1 - rd_wr $end
$scope module device $end
$var wire 32 . AD [31:0] $end
$var wire 4 / BE [3:0] $end
$var wire 1 * clk $end
$var wire 2 0 devaddress [1:0] $end
$var wire 1 + force_req $end
$var wire 1 , gnt $end
$var wire 1 - rd_wr $end
$var wire 1 " trdy $end
$var wire 3 1 state [2:0] $end
$var wire 1 # req $end
$var wire 1 $ irdy $end
$var wire 1 2 fvalid $end
$var wire 1 3 freq_pending $end
$var wire 1 % frame $end
$var wire 1 4 ffinished $end
$var wire 1 5 fend_count $end
$var wire 1 6 fcount $end
$var wire 1 & devsel $end
$var wire 4 7 C_BE [3:0] $end
$scope module ic $end
$var wire 32 8 AD [31:0] $end
$var wire 4 9 BE [3:0] $end
$var wire 1 * clk $end
$var wire 2 : devaddress [1:0] $end
$var wire 1 + force_req $end
$var wire 32 ; mem1 [31:0] $end
$var wire 32 < mem2 [31:0] $end
$var wire 32 = mem3 [31:0] $end
$var wire 32 > mem4 [31:0] $end
$var wire 1 - rd_wr $end
$var wire 3 ? state [2:0] $end
$var wire 1 # req $end
$var wire 1 $ irdy $end
$var wire 1 2 fvalid $end
$var wire 1 3 freq_pending $end
$var wire 1 % frame $end
$var wire 1 4 ffinished $end
$var wire 1 5 fend_count $end
$var wire 1 6 fcount $end
$var wire 4 @ C_BE [3:0] $end
$var reg 1 A bus_is_mine $end
$var reg 2 B counter [1:0] $end
$var reg 3 C mp [2:0] $end
$upscope $end
$scope module sm $end
$var wire 1 * clk $end
$var wire 1 + force_req $end
$var wire 1 % frame $end
$var wire 1 , gnt $end
$var wire 1 $ irdy $end
$var wire 1 - rd_wr $end
$var wire 1 # req $end
$var wire 1 " trdy $end
$var wire 1 & devsel $end
$var reg 1 6 fcount $end
$var reg 1 5 fend_count $end
$var reg 1 4 ffinished $end
$var reg 1 D fgnt $end
$var reg 1 3 freq_pending $end
$var reg 1 2 fvalid $end
$var reg 3 E next_state [2:0] $end
$var reg 3 F state [2:0] $end
$upscope $end
$scope module tc $end
$var wire 32 G AD [31:0] $end
$var wire 4 H C_BE [3:0] $end
$var wire 1 * clk $end
$var wire 1 2 fvalid $end
$var wire 3 I state [2:0] $end
$var wire 1 " trdy $end
$var wire 1 & devsel $end
$var reg 32 J add [31:0] $end
$var reg 4 K command [3:0] $end
$var reg 32 L memory [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx L
bx K
bx J
b0 I
bz H
bz G
b0 F
b0 E
xD
bx C
bx B
xA
bz @
b0 ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bz 8
bz 7
x6
x5
x4
x3
x2
b0 1
bx 0
bx /
bz .
1-
1,
0+
0*
bx )
bx (
bz '
z&
x%
z$
x#
z"
bz !
$end
#1
b0 C
1*
#2
0*
#3
1*
#4
1#
z%
0A
16
05
b0 B
0*
b1 )
b1 0
b1 :
1+
#5
1*
#6
03
b1 B
0*
#7
1*
#8
b10 B
0*
#9
1*
#10
0#
15
06
b11 B
0*
bz )
bz 0
bz :
0+
#11
1*
#12
b1 E
1D
0*
0,
#13
1*
#14
b10 E
1#
0%
b1 '
b1 7
b1 @
b1 H
b1 !
b1 .
b1 8
b1 G
1A
13
0D
b1 1
b1 ?
b1 F
b1 I
0*
1,
#15
b1 K
b1 J
1*
#16
1&
1"
0$
bz '
bz 7
bz @
bz H
bz !
bz .
bz 8
bz G
b11 E
04
03
b10 1
b10 ?
b10 F
b10 I
0*
#17
1*
#18
0&
0"
b10101010101010101010101010101010 !
b10101010101010101010101010101010 .
b10101010101010101010101010101010 8
b10101010101010101010101010101010 G
bx '
bx 7
bx @
bx H
12
b11 1
b11 ?
b11 F
b11 I
0*
#19
b10101010101010101010101010101010 ;
1*
#20
b1 C
b10 B
0*
#21
b10101010101010101010101010101010 <
1*
#22
b10 C
b100 E
1%
b1 B
0*
#23
b10101010101010101010101010101010 =
1*
#24
1$
1&
1"
bz !
bz .
bz 8
bz G
z%
bz '
bz 7
bz @
bz H
b0 E
b100 1
b100 ?
b100 F
b100 I
b11 C
b0 B
0*
#25
1*
#26
z&
z"
z$
0A
14
b0 1
b0 ?
b0 F
b0 I
0*
#27
b0 C
1*
#28
0*
#29
1*
#30
0*
#31
1*
#32
0*
#33
1*
#34
0*
#35
1*
#36
0*
#37
1*
#38
0*
#39
1*
#40
0*
#41
1*
#42
0*
#43
1*
#44
0*
